## KeyExchange
### 考点: LCG密钥交换恢复、数学推导、二分法

考点其实很基础，不过很好的解释了为什么plainLCG不能用来设计密钥交换算法。
LCG的$p$和内置参数$s = a \times b$已知。定义：
$$
f(s) \equiv a \times s+b \space (mod \space p) \\
f^n(s) \equiv \underbrace{f(f(f(...f(f(s))...)))}_{n次} \space (mod \space p)
$$
假设A与B要利用这个基础的LCG，共享密钥，二者商定一个基础的公共值$s$，满足$s$小于$p$即可。
此时A生成一个小于$p$的随机数$sk_A$作为私钥，计算公钥$pk_A=f^{sk_A}(s)$；B生成一个小于$p$的随机数$sk_B$作为私钥，计算公钥$pk_B=f^{sk_B}(s)$。A和B把公钥$pk_A$和$pk_B$公开至共享信道，随后A计算$f^{sk_A}(pk_B)$，B计算$f^{sk_B}(pk_A)$，由于定义$f$函数满足性质：
$$
f^a(f^b(s))=f^{a+b}(s)
$$
故有：
$$
f^{sk_A}(pk_B)=f^{sk_A}(f^{sk_B}(s))=f^{sk_A+sk_B}(s)=f^{sk_B}(pk_A)
$$
此时二者完成密钥共享，$K=f^{sk_A+sk_B}(s)$。
由于$sk_A$和$sk_B$都非常大，因此在CTF环境下无法采取暴力破解的手段计算二者的私钥，但是可以发现这个过程存在一个最大的问题：LCG采用的线性算法具有同构性。
$$
f^n(s) \equiv \underbrace{f(f(f(...f(f(s))...)))}_{n次}  \space (mod \space p) \\
\equiv a(...a(a(as+b)+b)+b...)+b  \space (mod \space p)\\
\equiv a^ns +(a^{n-1}+a^{n-2}+...+1)b \space (mod \space p) \\
\equiv a's+b' \space (mod \space p)
$$
可以发现，迭代n次$f$函数得到的结果仍可以写成$a's+b'$的形式，如果我们定义一个内置参数为$a'$、$b'$的LCG，及其相关的计算函数$f'$，则有：
$$
f'(s) \equiv a' \times s+b' \space (mod \space p) \\
f^n(s) \equiv f'(s) \space (mod \space p)
$$
其中$a'=a^n$，$b'=(a^{n-1}+a^{n-2}+...+1)b=(a-1)^{-1}(a^n-1)b$。
从以上推导回到LCG密钥交换问题，可以发现：
$$
f^{sk_A}(s) \equiv a^{sk_A} \times s + (a-1)^{-1}(a^{sk_A}-1)b\space (mod \space p) \\
\Rightarrow (a-1)f^{sk_A}(s)\equiv (a-1) \times a^{sk_A} \times s +(a^{sk_A}-1)b\space (mod \space p)  \\
\Rightarrow [(a-1)s+b] \times a^{sk_A}\equiv (a-1)f^{sk_A}(s)+b\space (mod \space p) \\
\Rightarrow a^{sk_A}\equiv[(a-1)s+b]^{-1}[(a-1)f^{sk_A}(s)+b]\space (mod \space p) 
$$
同理可知：
$$
a^{sk_B}\equiv[(a-1)s+b]^{-1}[(a-1)f^{sk_B}(s)+b]\space (mod \space p) 
$$
此时可以破解共享密钥：
$$
K=f^{sk_A}(pk_B)=f^{sk_A}(f^{sk_B}(s)) \\
=a^{sk_A} \times f^{sk_B}(s) + (a-1)^{-1}(a^{sk_A}-1)b
$$
或者：
$$
K=f^{sk_B}(pk_A)=f^{sk_B}(f^{sk_A}(s)) \\
=a^{sk_B} \times f^{sk_A}(s) + (a-1)^{-1}(a^{sk_B}-1)b
$$
题中给出了$p$、$s$和$f^{sk_A}(s)$、$f^{sk_B}(s)$，在求解共享密钥时还需分解$s$得到$a$和$b$。

本题中给出了一个$leak=a^5-b^3$，可用这个泄漏值来分解$s$。由于$leak=a^5 - (\frac{s}{a})^3=a^5 - \frac{s^3}{a^3}$，可以看出函数$g(x)=x^5 - \frac{k^3}{x^3}$对$x$是单调递增的（$k$为常数），而题里又给出$a$、$b$均为512位，因此在$[2^{511},2^{512}]$内二分找一下即可分解$s$。

$K+s$被用作AES-CBC中的key加密flag，iv已知，解密一下即可。

```python
exp:
from Crypto.Util.number import *
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from hashlib import sha256
from random import randint
from libnum import invmod, n2s

p = 110045941581246566163852236169863726493322518614291259738650243772537777220447239564993293840178002270803358414801874876416861655681706091960526864981702297311975108477231430850046449802619712390151394990272883738498246287828012579651055043742174921894177086628278972268977919519134723993840866617728971125501
s = 103083435269546339253719292770367969157635923310796947624819807524514689714230038488629636887588073083408362510426148038690685619752778205013088349018307009939108678198113606930036410404549808586987764543060403391315169316818289657581541763263327670573813529568272160960214773113382466107788108424376942305179
pk_a = 104249886397359747249273092453488313866919664956033370839273165940023672119280749446507600277914299719461300855987124305389892009846065290488788845690592952592538823773157304003987554741970547804984472643400001801640946933980112156093413786073659705669257814748840719625590155866880068232234070029543099326008
pk_b = 73943176009325878591909652784371325868093784459904155452171082544674415915957790552228923092972996591011414909913381038800791214834557764389213534028507829053436031472854955231610581309098048200856194242071844838535785588222371659431886892907007805510914868507217421041100993332508303713741693778352086616092

leak = 29040777564893836055576935754958349303880224434489606637225123765874859084299305072404829973337935904266301029232783978449958360875461566254630838251549934932706914467564998782070045758886430608783726619661530870388938391442492043731894115397400015449950051951769344001061013880264004181568996494392695873947102851715933737547680797285706746028093745905399081868517548754953070086517995947839613006470389399208171194194504365074914947024889949570680226668773867669172700292722732348438746947857754535156207414199788546164281701388891687436649862876851080136461979528906440369488791240780833837652254029174364644864043838626162283607643013213942931346399529512644954169730170267869381208558883655869400666658812252861841021468606579935712846111089021383151894750921351386


left = 2 ** 511
right = 2 ** 512
mid = (left + right) // 2
while (mid ** 5 - ((s ** 3) // (mid ** 3))) != leak:
	if (mid ** 5 - ((s ** 3) // (mid ** 3))) > leak:
		right = mid
		mid = (left + right) // 2
	else:
		left = mid
		mid = (left + right) // 2

a = mid
b = s // mid

iv = long_to_bytes(0xe759b23de290a6d4ea11dab4b0c306f3)
c = b"\xa8\x83\x8b,\x14\x1ad\xfb\xfd\x12\xc6\xc1=\xa0+k\x05\xc7\xc9\xed\xde\xca>\x04\xe1;\xcc\xc1\xb6\x9a+\xe66d\xcf\x9b\xfftp\x81\xab\xbf(\x02\xcd\x0b\xa4\xc0Lpg\x83F\x82l\xad2\xdcI\x1ab\x08\x88\n"

m = (invmod((a-1) * s + b, p) * (pk_b * (a-1) + b)) % p
k = (invmod((a-1) * s + b, p) * (pk_a * (a-1) + b)) % p
shared1 = (m * pk_a + invmod(a-1, p) * (m-1) * b) % p
shared2 = (k * pk_b + invmod(a-1, p) * (k-1) * b) % p
assert shared1 == shared2

key = sha256(str(shared1 + s).encode()).digest()[:16]
cipher = AES.new(key, AES.MODE_CBC, iv=iv)
print(cipher.decrypt(c))
```